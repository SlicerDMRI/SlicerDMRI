<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet"" type="text/css" href="https://cdn.jsdelivr.net/npm/parcoord-es@2.2.10/dist/parcoords.css">

<style>
* {
  font: 12px sans-serif;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/parcoord-es@2.2.10/dist/parcoords.standalone.js"></script>

<body>

<div id="chart" class="parcoords" style="resize:both;width:100%;height:800px"></div>

<div id="categoricals"></div>

<p id="tractLabel">No image</p>
<img id="tractImage"></img>

<p>Sample from ABCD study</p>

<p><a href="https://github.com/SlicerDMRI/ORG-Atlases/blob/master/Tracts-in-ORG-800FC-100HCP.md">Tract key</a></p>

<script>

const dataToPlot = %%dataToPlot%%;

const categoricals = %%categoricals%%;

const renderState = {};

let colorByCategorical = "sex_x";

const colorFunction = function(dataObject) {

  let opacity = 0.6;
  Object.keys(renderState).forEach(categorical => {
    if (renderState[categorical][dataObject[categorical]] == false) {
      opacity = 0.0;
    }
  });

  if (colorByCategorical == "sex_x") {
    if (dataObject[colorByCategorical] == "M") {
      color = `rgba(0,0,200,${opacity})`
    } else {
      color = `rgba(200,100,100,${opacity})`
    }
  } else {
    if (dataObject[colorByCategorical] == "0") {
      color = `rgba(255,0,0,${opacity})`
    } else if (dataObject[colorByCategorical] == "1") {
      color = `rgba(0,255,0,${opacity})`
    } else {
      color = `rgba(0,0,255,${opacity})`
    }
  }

  return (color);
}

const userConfig = {
  markedLineWidth: 5,
  markedShadowColor: "#888",
}

var parcoords = ParCoords(userConfig)("#chart")
  .data(dataToPlot)
  //.mode("queue")
  .color(colorFunction)
  .render()
  .createAxes()
;

parcoords
  .brushMode("1D-axes-multi")
//  .brushMode("2D-strums")
//  .brushMode("angular")
//  .brushedColor("#00a")
  .alphaOnBrushed(0.4)
//  .reorderable(true)
;

parcoords.ctx.marked

function showTractImage(subject, tract) {
  const tractImage = document.getElementById("tractImage");
  tractImage.src = `./TractImages/${subject}/${tract}.jpg`;
  const tractLabel = document.getElementById("tractLabel");
  tractLabel.innerText = `${subject} ${tract}`;
}

function showTractInSlicer(subjectID, tract) {
  if (window.slicerPython) {
    const dataString = JSON.stringify({
      brushedSubjectID: subjectID,
      brushedTracts: [tract]
    });
    window.slicerPython.evalPython(`

slicer.modules.TractologyWidget.logic.showABCDBrushedTract(${dataString})

    `);
  }
}

function highlightCategoricals(subjectData) {
  Object.keys(categoricals).forEach(categorical => {
    Object.keys(categoricals[categorical]).forEach(valueKey => {
      const value = categoricals[categorical][valueKey];
      valueLabelID = categorical+"-label-"+value[0];
      const valueLabel = document.getElementById(valueLabelID);
      if (subjectData[categorical] == value[0]) {
        valueLabel.style = "font-weight: bold;";
      } else {
        valueLabel.style = "";
      }
    });
  });
}

parcoords.on("brush", brushedData => {
  parcoords.clear('marked');
  const brushedTracts = []
  const brushExtents = parcoords.brushExtents();
  Object.keys(brushExtents).forEach(brushExtent => {
    if (brushExtents[brushExtent].length > 0) {
      brushedTracts.push(brushExtent);
    }
  });
  if (brushedData.length > 0) {
    parcoords.mark([brushedData[0]]);

    const mode = "showBrushedTract";

    if (mode == "showBrushedTract") {
      showTractImage(brushedData[0].id, brushedTracts[0]);
      showTractInSlicer(brushedData[0].id, brushedTracts[0]);
      highlightCategoricals(brushedData[0]);
    }
  }
})


//
// select on mouseover
//
const chart = document.getElementById("chart");
let hoveredTract = undefined;
let closestSubject = undefined;
let hoveredSubjectID = undefined;
let pickedSubjectID = undefined;
let shownSubjectID = undefined;

for (let dimension of document.getElementsByClassName("dimension")) {
  dimension.addEventListener("mouseover", event => {
    hoveredTract = dimension.lastChild.getAttribute("dimension");
  });
}

chart.addEventListener("mousedown", event => {
  pickedSubjectID = hoveredSubjectID;
  event.stopPropagation();
  event.preventDefault();
}, {capture: true});

chart.addEventListener("mouseup", event => {
  pickedSubjectID = undefined;
}, {capture: true});

document.addEventListener("keydown", event => {
  if (event.key == "s") {
    showTractInSlicer(shownSubjectID, hoveredTract);
  }
});

chart.addEventListener("mouseleave", event => {
  parcoords.clear('marked');
  highlightCategoricals({});
});

chart.addEventListener("mousemove", event => {
  if (hoveredTract == undefined) {
    return;
  }
  const height = parcoords.height();
  let hoverFA = (height - event.layerY)/height;
  let closestFA = 2;
  for (subjectIndex in dataToPlot) {
    const subjectFA = dataToPlot[subjectIndex][hoveredTract];
    const deltaFA = Math.abs(subjectFA - hoverFA);
    if ( deltaFA < closestFA ) {
      closestFA = deltaFA;
      closestSubject = undefined;
    }
    if (closestSubject == undefined) {
      closestSubject = subjectIndex;
    }
  }
  hoveredSubjectID = dataToPlot[closestSubject].id;
  shownSubjectID = hoveredSubjectID;
  if (pickedSubjectID == undefined) {
    parcoords.clear('marked');
    parcoords.mark([dataToPlot[closestSubject]]);
  } else {
    shownSubjectID  = pickedSubjectID;
  }
  showTractImage(shownSubjectID, hoveredTract);
  highlightCategoricals(dataToPlot[closestSubject]);
});

parcoords.updateAxes();
parcoords.render();

//
// fix headers
//
function rotateLables() {
  const labelTexts = Array.from(document.getElementsByClassName("label"));
  labelTexts.forEach(labelText => { 
    labelText.setAttribute("transform", "translate(-4,60) rotate(-90)");
  });
}

setTimeout (rotateLables, 1000);



// turn off tickmarks
document.querySelectorAll(".axis .tick").forEach(tick => {
  tick.setAttribute("style", "opacity: 0")
});


//
// add categoricals UI
// - sets renderState used in colorFunction
//

const categoricalsDiv = document.querySelector("#categoricals");
const columns = Object.keys(categoricals).length;
categoricalsDiv.setAttribute("style", `display: grid; grid-template-columns: repeat(${columns}, 1fr)`);

Object.keys(categoricals).forEach(categorical => {
  renderState[categorical] = {};
  const categoryDiv = document.createElement("div");
  categoryDiv.setAttribute("style", "display: grid; grid-template-columns: repeat(1, 1fr)");
  categoricalsDiv.appendChild(categoryDiv);
  const categoryLabel = document.createElement("p");
  categoryLabel.innerText = categorical;
  categoryLabel.classList.add("categoryLabel");
  categoryLabel.addEventListener("click", (event) => {
    colorByCategorical = categorical;
    document.querySelectorAll(".categoryLabel").forEach(label => {label.style = ""});
    categoryLabel.style = "font-weight: bold;";
    parcoords.render();
  });
  categoryDiv.appendChild(categoryLabel);
  const valuesDiv = document.createElement("div");
  valuesDiv.setAttribute("style", "display: grid; grid-template-columns: repeat(2, 1fr)");
  categoryDiv.appendChild(valuesDiv);
  Object.keys(categoricals[categorical]).forEach(valueKey => {
     const valueCheck = document.createElement("input");
     const value = categoricals[categorical][valueKey];
     valueCheck.id = categorical+value[0];
     valueCheck.type = "checkbox";
     valueCheck.checked = true;
     renderState[categorical][value[0]] = true;
     valueCheck.addEventListener("change", (event) => {
       renderState[categorical][value[0]] = event.target.checked;
       parcoords.render();
     });
    const valueLabel = document.createElement("a");
    valueLabel.innerText = `${value[0]} (${value[1]})`;
    valueLabel.id = categorical+"-label-"+value[0];
    valuesDiv.appendChild(valueCheck);
    valuesDiv.appendChild(valueLabel);
  });
});



</script>

</body>
